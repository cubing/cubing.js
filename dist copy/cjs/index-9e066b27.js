"use strict";function t(t){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;return e}function e(t,e){return t/function(t,e){if(t>e){const s=t;t=e,e=s}for(;t>0;){const s=e%t;e=t,t=s}return e}(t,e)*e}class Perm{constructor(t){this.n=t.length,this.p=t}toString(){return"Perm["+this.p.join(" ")+"]"}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new Perm(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new Perm(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new Perm(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=new Array;for(let t=s;!e[t];t=this.p[t])i.push(1+t),e[t]=!0;t.push("("+i.join(",")+")")}return t.join("")}order(){let t=1;const s=new Array(this.n);for(let i=0;i<this.p.length;i++){if(s[i]||this.p[i]===i)continue;let o=0;for(let t=i;!s[t];t=this.p[t])o++,s[t]=!0;t=e(t,o)}return t}}class OrbitDef{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return function(t){let e=1;for(;t>1;)e*=t,t--;return e}(this.size)*Math.pow(this.mod,this.size)}}class OrbitsDef{constructor(t,e,s,i,o){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=i,this.moveops=o}toKsolve(t,e){const s=[];s.push("Name "+t),s.push("");for(let t=0;t<this.orbitnames.length;t++)s.push("Set "+this.orbitnames[t]+" "+this.orbitdefs[t].size+" "+this.orbitdefs[t].mod);s.push(""),s.push("Solved");for(let t=0;t<this.orbitnames.length;t++){s.push(this.orbitnames[t]);const e=this.solved.orbits[t].toKsolveVS();s.push(e[0]),s.push(e[1])}s.push("End"),s.push("");for(let t=0;t<this.movenames.length;t++){s.push("Move "+this.movenames[t]);for(let i=0;i<this.orbitnames.length;i++){if(!e&&this.moveops[t].orbits[i].isIdentity())continue;s.push(this.orbitnames[i]);const o=this.moveops[t].orbits[i].toKsolve();s.push(o[0]),s.push(o[1])}s.push("End"),s.push("")}return s}toKpuzzle(){const t={},e={};for(let s=0;s<this.orbitnames.length;s++)t[this.orbitnames[s]]={numPieces:this.orbitdefs[s].size,orientations:this.orbitdefs[s].mod},e[this.orbitnames[s]]=this.solved.orbits[s].toKpuzzle();const s={};for(let t=0;t<this.movenames.length;t++){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=this.moveops[t].orbits[s].toKpuzzle();s[this.movenames[t]]=e}return{orbits:t,startPieces:e,moves:s}}optimize(){const t=[],e=[],s=[],i=[];for(let t=0;t<this.moveops.length;t++)i.push([]);for(let o=0;o<this.orbitdefs.length;o++){const n=this.orbitdefs[o].mod,r=this.orbitdefs[o].size,h=new DisjointUnion(r),l=new Array(this.orbitdefs[o].size);for(let t=0;t<r;t++)l[t]=!1;for(let t=0;t<this.moveops.length;t++)for(let e=0;e<r;e++)this.moveops[t].orbits[o].perm[e]===e&&0===this.moveops[t].orbits[o].ori[e]||(l[e]=!0,h.union(e,this.moveops[t].orbits[o].perm[e]));let a=!0;if(n>1){a=!1;const t=new DisjointUnion(this.orbitdefs[o].size*n);for(let e=0;e<this.moveops.length;e++)for(let s=0;s<r;s++)if(this.moveops[e].orbits[o].perm[s]!==s||0!==this.moveops[e].orbits[o].ori[s])for(let i=0;i<n;i++)t.union(s*n+i,this.moveops[e].orbits[o].perm[s]*n+(i+this.moveops[e].orbits[o].ori[s])%n);for(let e=0;!a&&e<r;e++)for(let s=1;s<n;s++)t.find(e*n)===t.find(e*n+s)&&(a=!0);for(let t=0;!a&&t<r;t++)for(let e=0;e<t;e++)this.solved.orbits[o].perm[t]===this.solved.orbits[o].perm[e]&&(a=!0)}let c=-1,f=!1;for(let t=0;t<this.orbitdefs[o].size;t++)if(l[t]){const e=h.find(t);c<0?c=e:c!==e&&(f=!0)}for(let n=0;n<this.orbitdefs[o].size;n++){if(!l[n])continue;if(h.find(n)!==n)continue;const r=[],c=[];let u=0;for(let t=0;t<this.orbitdefs[o].size;t++)h.find(t)===n&&(r[u]=t,c[t]=u,u++);if(f?t.push(this.orbitnames[o]+"_p"+n):t.push(this.orbitnames[o]),a){e.push(new OrbitDef(u,this.orbitdefs[o].mod)),s.push(this.solved.orbits[o].remapVS(r,u));for(let t=0;t<this.moveops.length;t++)i[t].push(this.moveops[t].orbits[o].remap(r,c,u))}else{e.push(new OrbitDef(u,1)),s.push(this.solved.orbits[o].remapVS(r,u).killOri());for(let t=0;t<this.moveops.length;t++)i[t].push(this.moveops[t].orbits[o].remap(r,c,u).killOri())}}}return new OrbitsDef(t,e,new VisibleState(s),this.movenames,i.map(t=>new Transformation(t)))}scramble(t){const e=[];for(let t=0;t<this.moveops.length;t++)e[t]=this.moveops[t];for(let t=0;t<e.length;t++){const s=Math.floor(Math.random()*e.length),i=e[t];e[t]=e[s],e[s]=i}t<e.length&&(t=e.length);for(let s=0;s<t;s++){const t=Math.floor(Math.random()*e.length),s=Math.floor(Math.random()*e.length),i=Math.floor(Math.random()*this.moveops.length);e[t]=e[t].mul(e[s]).mul(this.moveops[i]),Math.random()<.1&&(e[t]=e[t].mul(this.moveops[i]))}let s=e[0];for(let t=1;t<e.length;t++)s=s.mul(e[t]);this.solved=this.solved.mul(s)}reassemblySize(){let t=1;for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}}class Orbit{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(e,s){return new Orbit(t(e),function(t){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;return e}(e),s)}mul(t){const e=this.perm.length,s=new Array(e),i=new Array(e);for(let o=0;o<e;o++)s[o]=this.perm[t.perm[o]],i[o]=(this.ori[t.perm[o]]+t.ori[o])%this.orimod;return new Orbit(s,i,this.orimod)}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let i=0;i<t;i++)e[this.perm[i]]=i,s[this.perm[i]]=(this.orimod-this.ori[i])%this.orimod;return new Orbit(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(1===t)return new Perm(this.perm);const e=this.perm.length,s=new Array(e*t);for(let i=0;i<e;i++)for(let e=0;e<t;e++)s[i*t+e]=t*this.perm[i]+(this.ori[i]+e)%t;return new Perm(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let i=0;i<e;i++){const o=this.perm[i];if(void 0===t[o]){const n=[i];t[o]=!0;for(let t=i+1;t<e;t++)this.perm[t]===o&&n.push(t);s.push(n)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;for(let e=0;e<t;e++)if(this.perm[e]!==e||0!==this.ori[e])return!1;return!0}remap(t,e,s){const i=new Array(s),o=new Array(s);for(let n=0;n<s;n++)i[n]=e[this.perm[t[n]]],o[n]=this.ori[t[n]];return new Orbit(i,o,this.orimod)}remapVS(t,e){const s=new Array(e),i=new Array(e);let o=0;const n=[];for(let r=0;r<e;r++){const e=this.perm[t[r]];void 0===n[e]&&(n[e]=o++),s[r]=n[e],i[r]=this.ori[t[r]]}return new Orbit(s,i,this.orimod)}toKsolveVS(){return[this.perm.map(t=>t+1).join(" "),this.ori.join(" ")]}toKsolve(){const t=new Array(this.ori.length);for(let e=0;e<t.length;e++)t[this.perm[e]]=this.ori[e];return[this.perm.map(t=>t+1).join(" "),t.join(" ")]}toKpuzzle(){return{permutation:this.perm,orientation:this.ori}}}class TransformationBase{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(let e=0;e<this.orbits.length;e++)t.push(this.orbits[e].inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(let t=0;t<this.orbits.length;t++)this.orbits[t].killOri();return this}toPerm(){const t=new Array;let e=0;for(let s=0;s<this.orbits.length;s++){const i=this.orbits[s].toPerm();t.push(i),e+=i.n}const s=new Array(e);e=0;for(let i=0;i<this.orbits.length;i++){const o=t[i];for(let t=0;t<o.n;t++)s[e+t]=e+o.p[t];e+=o.n}return new Perm(s)}identicalPieces(){const t=[];let e=0;for(let s=0;s<this.orbits.length;s++){const i=this.orbits[s].orimod,o=this.orbits[s].identicalPieces();for(let s=0;s<o.length;s++)t.push(o[s].map(t=>t*i+e));e+=i*this.orbits[s].perm.length}return t}order(){let t=1;for(let s=0;s<this.orbits.length;s++)t=e(t,this.orbits[s].order());return t}}class Transformation extends TransformationBase{constructor(t){super(t)}mul(t){return new Transformation(this.internalMul(t))}mulScalar(t){if(0===t)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);0==(1&t);)e=e.mul(e),t>>=1;if(1===t)return e;let s=e,i=this.e();for(;t>0;)1&t&&(i=i.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return i}inv(){return new Transformation(this.internalInv())}e(){return new Transformation(this.orbits.map(t=>Orbit.e(t.perm.length,t.orimod)))}}class VisibleState extends TransformationBase{constructor(t){super(t)}mul(t){return new VisibleState(this.internalMul(t))}}class DisjointUnion{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),i=this.find(e);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}}function s(t){let e=new Quat(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function i(t,e,s,i){const o=i[t].intersect3(i[e],i[s]);if(!o)return o;for(let n=0;n<i.length;n++)if(n!==t&&n!==e&&n!==s){const t=i[n].b*o.b+i[n].c*o.c+i[n].d*o.d;if(i[n].a>0&&t>i[n].a||i[n].a<0&&t<i[n].a)return!1}return o}class Quat{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}mul(t){return new Quat(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return"Q["+this.a+","+this.b+","+this.c+","+this.d+"]"}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new Quat(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new Quat(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new Quat(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new Quat(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new Quat(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new Quat(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new Quat(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new Quat(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,i,o,n,r,h,l){return t*(o*l-n*h)+e*(n*r-i*l)+s*(i*h-o*r)}rotateplane(t){const e=t.mul(new Quat(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){const e=this;return t.map(t=>t.rotatepoint(e))}rotatecubie(t){const e=this;return t.map(t=>e.rotateface(t))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return!(Math.abs(s)<1e-9)&&new Quat(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>1e-9?1:t<-1e-9?-1:0}cutfaces(t){const e=this,s=this.a,i=[];for(let o=0;o<t.length;o++){const n=t[o],r=n.map(t=>e.side(t.dot(e)-s));let h=0;for(let t=0;t<r.length;t++)h|=1<<r[t]+1;if(5==(5&h))for(let t=-1;t<=1;t+=2){const e=[];for(let i=0;i<n.length;i++){r[i]!==t&&0!==r[i]||e.push(n[i]);const o=(i+1)%n.length;if(r[i]+r[o]===0&&0!==r[i]){const t=n[i].dot(this)-s,r=t/(t-(n[o].dot(this)-s)),h=n[i].smul(1-r).sum(n[o].smul(r));e.push(h)}}i.push(e)}else i.push(n)}return i}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const i=this.side(t[s].dot(this)-e);if(0!==i)return i}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<1e-9||e.dist(s.smul(-1))<1e-9}makecut(t){return new Quat(t,this.b,this.c,this.d)}}function o(t,e){const s=[],i=[];for(let o=0;o<e.length;o++){const n=t.rotateplane(e[o]);let r=!1;for(let t=0;t<s.length;t++)if(n.dist(s[t])<1e-9){r=!0;break}r||(s.push(n),i.push(e[o]))}return i}function n(t){const e=[];for(let s=1;s<t.length;s++)for(let o=s+1;o<t.length;o++){const n=i(0,s,o,t);if(n){let t=!1;for(let s=0;s<e.length;s++)if(n.dist(e[s])<1e-9){t=!0;break}t||e.push(n)}}for(;;){let s=!1;for(let i=0;i<e.length;i++){const o=(i+1)%e.length;if(t[0].dot(e[i].cross(e[o]))<0){const t=e[i];e[i]=e[o],e[o]=t,s=!0}}if(!s)break}return e}const r={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667","Jing pyraminx":"t f 0","master paramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",pentultimate:"d f 0",starminx:"d v 0.93796236956","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.93796236956"},h={4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","N",""],["N","D","","B"],["B","N","U","M"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]},l={4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#e085b9",F:"#080d99",R:"#c1e35c",D:"#22955e",B:"#9121ab",L:"#b27814",M:"#0d35ad",N:"#eb126b"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}},a={4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","B","D","U","N","L","R","M"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]};function c(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<1e-9)return s;throw new Error("Element not found")}function f(){return r}function u(t){return r[t]}function m(t){const e=t.split(/ /).filter(Boolean);if(e.length%2==0)return!1;if("o"!==e[0]&&"c"!==e[0]&&"i"!==e[0]&&"d"!==e[0]&&"t"!==e[0])return!1;const s=[];for(let t=1;t<e.length;t+=2){if("f"!==e[t]&&"v"!==e[t]&&"e"!==e[t])return!1;s.push([e[t],e[t+1]])}return[e[0],s]}function p(t,e=[]){const[s,i]=m(t),o=new PuzzleGeometry(s,i,["allmoves","true"].concat(e));return o.allstickers(),o.genperms(),o}function g(t,e=[]){return p(r[t],e)}function d(t,e,s){let i=0,o=!1;for(let t=0;t<=s;t++)e>>t&1&&(i|=1<<s-t);i<e&&(t=[t[2],t[3],t[0],t[1]],e=i,o=!0);let n=t[0],r="",h=0;for(;e>>1+h;)h++;return e===(2<<s)-1?n+="v":e===1<<h?h>0&&(r=String(h+1)):e===(2<<h)-1?(n=n.toLowerCase(),h>1&&(r=String(h+1))):r="_"+e+"_",[r+n,o]}function b(t,e){const s=[];let i=0;for(;i<t.length;){let o=!1;for(let n=0;n<e.length;n++)if(t.substr(i).startsWith(e[n][1])){s.push(e[n][1]),i+=e[n][1].length,o=!0;break}if(!o)throw new Error("Could not split "+t+" into face names.")}return s}function v(t,e){return[-t.b/e,-t.c/e,-t.d/e]}function w(t,e){const s=[],i=t.length;for(let o=0;o<i;o++)s[i-o-1]=v(t[o],e);return s}function x(t,e){const s=[];for(let i=1;i<10;i++){for(let i=0;i<t.length;i++){const o=(i+t.length-1)%t.length,n=(i+1)%t.length,r=t[o].sub(t[i]).normalize(),h=t[n].sub(t[i]).normalize(),l=r.dot(h),a=e/Math.sqrt(1-l*l);s[i]=t[i].sum(r.sum(h).smul(a))}let i=!0;for(let e=0;i&&e<s.length;e++){const o=(e+t.length-1)%t.length,n=(e+1)%t.length;s[o].sub(s[e]).cross(s[n].sub(s[e])).dot(s[e])>=0&&(i=!1)}if(i)return s;e/=2}return t}class PuzzleGeometry{constructor(t,e,s){if(this.args="",this.cmovesbyslice=[],this.verbose=0,this.allmoves=!1,this.cornersets=!0,this.centersets=!0,this.edgesets=!0,this.graycorners=!1,this.graycenters=!1,this.grayedges=!1,this.killorientation=!1,this.optimize=!1,this.scramble=0,this.fixPiece="",this.orientCenters=!1,this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],void 0!==s){if(s.length%2!=0)throw new Error("Odd length in option list?");for(let t=0;t<s.length;t+=2)if("verbose"===s[t])this.verbose++;else if("quiet"===s[t])this.verbose=0;else if("allmoves"===s[t])this.allmoves=s[t+1];else if("outerblockmoves"===s[t])this.outerblockmoves=s[t+1];else if("vertexmoves"===s[t])this.vertexmoves=s[t+1];else if("rotations"===s[t])this.addrotations=s[t+1];else if("cornersets"===s[t])this.cornersets=s[t+1];else if("centersets"===s[t])this.centersets=s[t+1];else if("edgesets"===s[t])this.edgesets=s[t+1];else if("graycorners"===s[t])this.graycorners=s[t+1];else if("graycenters"===s[t])this.graycenters=s[t+1];else if("grayedges"===s[t])this.grayedges=s[t+1];else if("movelist"===s[t])this.movelist=s[t+1];else if("killorientation"===s[t])this.killorientation=s[t+1];else if("optimize"===s[t])this.optimize=s[t+1];else if("scramble"===s[t])this.scramble=s[t+1];else if("fix"===s[t])this.fixPiece=s[t+1];else{if("orientcenters"!==s[t])throw new Error("Bad option while processing option list "+s[t]);this.orientCenters=s[t+1]}}this.args=t+" "+e.map(t=>t.join(" ")).join(" "),s&&(this.args+=" "+s.join(" ")),this.verbose>0&&console.log(this.header("# ")),this.create(t,e)}create(t,e){this.moveplanes=[],this.faces=[],this.cubies=[];let s=null;switch(t){case"c":s=function(){const t=Math.sqrt(.5);return[new Quat(t,t,0,0),new Quat(t,0,t,0)]}();break;case"o":s=function(){const t=Math.sqrt(.5);return[new Quat(.5,.5,.5,.5),new Quat(t,0,0,t)]}();break;case"i":s=function(){let t=1/6+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const i=2*Math.PI/6;return[new Quat(Math.cos(i),t*Math.sin(i),e*Math.sin(i),0),new Quat(Math.cos(i),-t*Math.sin(i),e*Math.sin(i),0)]}();break;case"t":s=[new Quat(.5,.5,.5,.5),new Quat(.5,.5,.5,-.5)];break;case"d":s=function(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const i=Math.sqrt(e*e+s*s);return e/=i,s/=i,[new Quat(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new Quat(.5,.5,.5,.5)]}();break;default:throw new Error("Bad shape argument: "+t)}this.rotations=function(t){const e=[new Quat(1,0,0,0)];for(let s=0;s<e.length;s++)for(let i=0;i<t.length;i++){const o=t[i].mul(e[s]),n=o.smul(-1);let r=!1;for(let t=0;t<e.length;t++)if(o.dist(e[t])<1e-9||n.dist(e[t])<1e-9){r=!0;break}r||e.push(o)}return e}(s),this.verbose&&console.log("# Rotations: "+this.rotations.length);const i=s[0];this.baseplanerot=o(i,this.rotations);const r=this.baseplanerot.map(t=>i.rotateplane(t));this.baseplanes=r,this.basefacecount=r.length;const f=h[r.length];this.net=f,this.colors=l[r.length],this.faceorder=a[r.length],this.verbose&&console.log("# Base planes: "+r.length);const u=n(r);this.verbose&&console.log("# Face vertices: "+u.length);const m=r[0].makenormal(),p=u[0].sum(u[1]).makenormal(),g=u[0].makenormal(),d=[];for(let t=0;t<e.length;t++){let s=null;switch(e[t][0]){case"f":s=m;break;case"v":s=g;break;case"e":s=p;break;default:throw new Error("Bad cut argument: "+e[t][0])}d.push(s.makecut(e[t][1]))}const b=new Quat(1,m.b,m.c,m.d);this.verbose&&console.log("# Boundary is "+b);let v=[n(o(b,this.rotations).map(t=>b.rotateplane(t)))];this.basefaces=[];for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(v[0]);this.basefaces.push(e)}const w=[],x=[],y=[],k=[],z=v[0].length;function M(t,e,s){for(let i=0;i<t.length;i++)if(t[i][0].dist(e)<1e-9)return void t[i].push(s);t.push([e,s])}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(v[0]);for(let s=0;s<e.length;s++){const i=(s+1)%e.length;M(k,e[s].sum(e[i]).smul(.5),t)}}const E=[];for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(v[0]),s=[];for(let i=0;i<e.length;i++){const o=(i+1)%e.length,n=k[c(k,e[i].sum(e[o]).smul(.5))];if(t===n[1])s.push(n[2]);else{if(t!==n[2])throw new Error("Could not find edge");s.push(n[1])}}E.push(s)}const P={},O=[];O.push(f[0][0]),P[f[0][0]]=0,O[E[0][0]]=f[0][1],P[f[0][1]]=E[0][0];for(let t=0;t<f.length;t++){const e=P[f[t][0]];if(void 0===e)throw new Error("Bad edge description; first edge not connected");let s=-1;for(let i=0;i<E[e].length;i++){const o=O[E[e][i]];if(void 0!==o&&o===f[t][1]){s=i;break}}if(s<0)throw new Error("First element of a net not known");for(let i=2;i<f[t].length;i++){if(""===f[t][i])continue;const o=E[e][(i+s-1)%z],n=O[o];if(void 0!==n&&n!==f[t][i])throw new Error("Face mismatch in net");O[o]=f[t][i],P[f[t][i]]=o}}for(let t=0;t<O.length;t++){let e=!1;for(let s=0;s<this.faceorder.length;s++)if(O[t]===this.faceorder[s]){this.faceprecedence[t]=s,e=!0;break}if(!e)throw new Error("Could not find face "+O[t]+" in face order list "+this.faceorder)}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(v[0]),s=b.rotateplane(this.baseplanerot[t]),i=O[t];w.push([e,i]),x.push([s,i])}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(v[0]),s=O[t];for(let t=0;t<e.length;t++){const i=(t+1)%e.length,o=e[t].sum(e[i]).smul(.5),n=(t+2)%e.length,r=e[i].sum(e[n]).smul(.5),h=c(k,o),l=c(k,r);M(y,e[i],[s,l,h])}}for(let t=0;t<k.length;t++){if(3!==k[t].length)throw new Error("Bad length in edge names "+k[t]);let e=O[k[t][1]];const s=O[k[t][2]];this.faceprecedence[k[t][1]]<this.faceprecedence[k[t][2]]?e+=s:e=s+e,k[t]=[k[t][0],e]}this.cornerfaces=y[0].length-1;for(let t=0;t<y.length;t++){if(y[t].length<4)throw new Error("Bad length in vertex names");let e=1;for(let s=2;s<y[t].length;s++)this.faceprecedence[P[y[t][s][0]]]<this.faceprecedence[P[y[t][e][0]]]&&(e=s);let s="";for(let i=1;i<y[t].length;i++){s+=y[t][e][0];for(let s=1;s<y[t].length;s++)if(y[t][e][2]===y[t][s][1]){e=s;break}}y[t]=[y[t][0],s]}this.verbose>1&&(console.log("Face precedence list: "+this.faceorder.join(" ")),console.log("Face names: "+w.map(t=>t[1]).join(" ")),console.log("Edge names: "+k.map(t=>t[1]).join(" ")),console.log("Vertex names: "+y.map(t=>t[1]).join(" ")));const D=[];for(let t=0;t<x.length;t++)D.push([x[t][0].makenormal(),x[t][1],"f"]);for(let t=0;t<k.length;t++)D.push([k[t][0].makenormal(),k[t][1],"e"]);for(let t=0;t<y.length;t++)D.push([y[t][0].makenormal(),y[t][1],"v"]);this.facenames=w,this.faceplanes=x,this.edgenames=k,this.vertexnames=y,this.geonormals=D;const B=new Quat(0,0,0,0);this.edgedistance=v[0][0].sum(v[0][1]).smul(.5).dist(B),this.vertexdistance=v[0][0].dist(B),this.verbose&&console.log("# Distances: face 1 edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let t=0;t<d.length;t++)for(let e=0;e<this.rotations.length;e++){const s=d[t].rotateplane(this.rotations[e]);let i=!1;for(let t=0;t<this.moveplanes.length;t++)if(s.sameplane(this.moveplanes[t])){i=!0;break}i||(this.moveplanes.push(s),v=s.cutfaces(v))}this.faces=v,this.verbose&&console.log("# Faces is now "+v.length),this.stickersperface=v.length;let Q=1e99;for(let t=0;t<v.length;t++)for(let e=0;e<v[t].length;e++){const s=(e+1)%v[t].length,i=v[t][e].dist(v[t][s]);i<Q&&(Q=i)}this.shortedge=Q,this.verbose&&console.log("# Short edge is "+Q)}keyface(t){let e="";for(let s=0;s<this.moveplanesets.length;s++){let i=0;for(let e=0;e<this.moveplanesets[s].length;e++)this.moveplanesets[s][e].faceside(t)>0&&i++;e=e+" "+i}return e}findcubie(t){return this.facetocubies[this.findface(t)][0]}findface(t){const e=s(t),i=this.keyface(t);for(let t=0;t<this.facelisthash[i].length;t++){const o=this.facelisthash[i][t];if(Math.abs(e.dist(s(this.faces[o])))<1e-9)return o}throw new Error("Could not find face.")}project2d(t,e,s){const i=this.facenames[t][0],o=(e+1)%i.length,n=this.baseplanes[t];let r=i[o].sub(i[e]);const h=r.len();r=r.normalize();const l=r.cross(n).normalize();let a=s[1].sub(s[0]);const c=a.len()/h;a=a.normalize();const f=a.b,u=a.c,m=r.smul(f).sub(l.smul(u)).smul(c),p=l.smul(f).sum(r.smul(u)).smul(c),g=new Quat(0,s[0].b-m.dot(i[e]),s[0].c-p.dot(i[e]),0);return[m,p,g]}allstickers(){this.faces=function(t,e){const s=[];for(let i=0;i<t.length;i++)for(let o=0;o<e.length;o++){const n=e[o],r=[];for(let e=0;e<n.length;e++)r.push(n[e].rotateplane(t[i]));s.push(r)}return s}(this.baseplanerot,this.faces),this.verbose&&console.log("# Total stickers is now "+this.faces.length);const t=[];for(let e=0;e<this.moveplanes.length;e++){let s=!1;const i=this.moveplanes[e],o=i.makenormal();for(let e=0;e<t.length;e++)if(o.sameplane(t[e][0].makenormal())){t[e].push(i),s=!0;break}s||t.push([i])}for(let e=0;e<t.length;e++){const s=t[e].map(t=>t.normalizeplane()),i=s[0].makenormal();for(let t=0;t<s.length;t++)s[t].makenormal().dist(i)>1e-9&&(s[t]=s[t].smul(-1));s.sort((t,e)=>t.a-e.a),t[e]=s}this.moveplanesets=t;const e=t.map(t=>t.length);this.verbose&&console.log("# Move plane sets: "+e);const i=[];for(let e=0;e<t.length;e++)i.push([]);for(let e=0;e<this.rotations.length;e++){const s=this.rotations[e];if(Math.abs(Math.abs(s.a)-1)<1e-9)continue;const o=s.makenormal();for(let e=0;e<t.length;e++)if(o.sameplane(t[e][0].makenormal())){i[e].push(s);break}}this.moverotations=i;for(let e=0;e<i.length;e++){const s=i[e],o=s[0].makenormal();for(let t=0;t<s.length;t++)o.dist(s[t].makenormal())>1e-9&&(s[t]=s[t].smul(-1));s.sort((t,e)=>t.angle()-e.angle()),i[e][0].dot(t[e][0])<0&&s.reverse()}const o=i.map(t=>1+t.length);this.movesetorders=o;const n=[];for(let e=0;e<t.length;e++){const s=t[e][0].makenormal();let i=null,o=null;for(let t=0;t<this.geonormals.length;t++){const e=s.dot(this.geonormals[t][0]);Math.abs(e-1)<1e-9?o=[this.geonormals[t][1],this.geonormals[t][2]]:Math.abs(e+1)<1e-9&&(i=[this.geonormals[t][1],this.geonormals[t][2]])}if(null===o||null===i)throw new Error("Saw positive or negative sides as null");n.push([o[0],o[1],i[0],i[1],1+t[e].length])}this.movesetgeos=n;const r={},h={},l={},a=[],c=[],f=this.faces;for(let t=0;t<f.length;t++){const e=f[t],s=this.keyface(e);if(r[s]||(l[s]=c.length,a.push(s),r[s]=[],h[s]=[],c.push(r[s])),h[s].push(t),r[s].push(e),h[s].length===this.basefacecount){this.verbose&&console.log("# Splitting core.");for(let t=0;t<this.basefacecount;t++){const e=s+" "+t;h[e]=[h[s][t]],r[e]=[r[s][t]],a.push(e),l[e]=c.length,c.push(r[e])}r[s]=[],c[l[s]]=[]}}this.cubiekey=l,this.facelisthash=h,this.cubiekeys=a,this.verbose&&console.log("# Cubies: "+Object.keys(r).length);const u=this;function m(t){const e=u.stickersperface;return Math.floor(t/e)}this.cubies=c;for(let t=0;t<c.length;t++){const e=c[t];if(e.length<2)continue;if(e.length===this.basefacecount)continue;if(e.length>5)throw new Error("Bad math; too many faces on this cubie "+e.length);const i=h[this.keyface(e[0])],o=e.map(t=>s(t)),n=s(o);for(let t=0;e.length>2;t++){let s=!1;for(let t=0;t<e.length;t++){const r=(t+1)%e.length;if(n.dot(o[t].cross(o[r]))<0){const n=e[t];e[t]=e[r],e[r]=n;const h=o[t];o[t]=o[r],o[r]=h;const l=i[t];i[t]=i[r],i[r]=l,s=!0}}if(!s)break;if(t>1e3)throw new Error("Bad epsilon math; too close to border")}let r=0,l=this.findface(e[r]);for(let t=1;t<e.length;t++){const s=this.findface(e[t]);this.faceprecedence[m(s)]<this.faceprecedence[m(l)]&&(r=t,l=s)}if(0!==r){const t=e.slice(),s=i.slice();for(let o=0;o<e.length;o++)e[o]=t[(r+o)%e.length],i[o]=s[(r+o)%e.length]}}const p=[];for(let t=0;t<c.length;t++){const e=h[a[t]];for(let s=0;s<e.length;s++)p[e[s]]=[t,s]}this.facetocubies=p;const g=["?","CENTER","EDGE","CORNER","C4RNER","C5RNER"],d=[],b=[0,0,0,0,0,0],v=[],w=[];let x=0;const y=[],k=[],z=[],M=[];const E=[];for(let t=0;t<c.length;t++){if(w[t])continue;const e=c[t];if(0===e.length)continue;const s={};let o=0;z.push(0),E.push([]);const n=e.length,r=b[n]++;let h=g[n];void 0!==h&&n!==this.basefacecount||(h="CORE"),h+=0===r?"":r+1,d[x]=h,v[x]=n;const l=[t];let a=0;for(w[t]=!0;a<l.length;){const t=l[a++],n=c[t].map(t=>m(u.findface(t))).join(" ");(e.length>1||void 0===s[n])&&(s[n]=o++),M[t]=s[n],y[t]=x,E[x].push(t),k[t]=z[x]++;for(let e=0;e<i.length;e++){const s=this.findcubie(i[e][0].rotateface(c[t][0]));w[s]||(l.push(s),w[s]=!0)}}x++}if(this.orbits=z.length,this.cubiesetnums=y,this.cubieordnums=k,this.cubiesetnames=d,this.cubieords=z,this.orbitoris=v,this.cubievaluemap=M,this.cubiesetcubies=E,""!==this.fixPiece){for(let t=0;t<c.length;t++)if("v"===this.fixPiece&&c[t].length>2||"e"===this.fixPiece&&2===c[t].length||"f"===this.fixPiece&&1===c[t].length){this.fixedCubie=t;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.fixPiece+" to fix.")}this.verbose&&console.log("# Cubie orbit sizes "+z)}spinmatch(t,e){if(t===e)return!0;if(t.length!==e.length)return!1;try{const s=b(t,this.facenames),i=b(e,this.facenames);if(s.length!==i.length)return!1;for(let t=0;t<s.length;t++)if(s[t]===i[0]){for(let e=0;e<i.length;e++)if(s[(t+e)%s.length]!==i[e])return!1;return!0}return!1}catch(t){return!1}}parsemove(t){const e=RegExp("^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$"),s=t.match(e);if(null===s)throw new Error("Bad move passed "+t);let i,o=s[4],n=!1;if(o.endsWith("v")&&o[0]<="Z"){if(void 0!==s[2]||void 0!==s[3])throw new Error("Cannot use a prefix with full cube rotations");o=o.slice(0,-1),n=!0}let r=-1;const h=o.toUpperCase();let l=!1;for(let t=0;t<this.movesetgeos.length;t++){const e=this.movesetgeos[t];this.spinmatch(e[0],h)&&(l=!0,i=e,r=t),this.spinmatch(e[2],h)&&(l=!1,i=e,r=t)}let a=1,c=1;if(h!==o&&(c=2),void 0===i)throw new Error("Bad grip in move "+t);if(void 0!==s[2]){if(void 0===s[3])throw new Error("Missing second number in range");a=parseInt(s[2],10)}if(void 0!==s[3]&&(void 0===s[2]?(c=parseInt(s[3],10),a=h===o?c:1):c=parseInt(s[3],10)),a--,c--,n&&(a=0,c=this.moveplanesets[r].length),a<0||a>this.moveplanesets[r].length||c<0||c>this.moveplanesets[r].length)throw new Error("Bad slice spec "+a+" "+c);let f="1",u=1;return void 0!==s[5]&&(f=s[5],"'"===f[0]&&(f="-"+f.substring(1)),"+"===f[0]?f=f.substring(1):"-"===f[0]&&"-"===f&&(f="-1"),u=parseInt(f,10)),[t,r,a,c,l,u]}genperms(){if(this.cmovesbyslice.length>0)return;const t=[],e=[];for(let s=0;s<this.moveplanesets.length;s++){const i=this.moveplanesets[s],o=[],n=[];for(let t=0;t<this.faces.length;t++){const e=this.faces[t];let s=0;for(let t=0;t<i.length;t++)i[t].faceside(e)<0&&s++;for(o.push(s);n.length<=s;)n.push(0);n[s]++}const r=[],h=[];for(let t=0;t<n.length;t++){const e=[],i=[],n=[];for(let r=0;r<this.faces.length;r++){if(o[r]!==t)continue;const h=[r],l=this.facetocubies[r].slice();let a=this.faces[r],c=r;for(;;){o[c]=-1;const e=this.moverotations[s][0].rotateface(a);if(c=this.findface(e),o[c]<0)break;if(o[c]!==t)throw new Error("Bad movement?");h.push(c);const i=this.facetocubies[c];l.push(i[0],i[1]),a=e}if(1===h.length&&this.orientCenters){for(let t=1;t<this.movesetorders[s];t++)h.push(h[0]),l.push(l[0],t),this.cubies[l[0]].push(this.cubies[l[0]][0]);this.duplicatedFaces[h[0]]=this.movesetorders[s],this.duplicatedCubies[l[0]]=this.movesetorders[s],this.orbitoris[this.cubiesetnums[l[0]]]=this.movesetorders[s]}h.length>1&&e.push(h),l.length>2&&!n[l[0]]&&i.push(l);for(let t=0;t<l.length;t+=2)n[l[t]]=!0}r.push(e),h.push(i)}t.push(r),e.push(h)}if(this.movesbyslice=t,this.cmovesbyslice=e,void 0!==this.movelist){const t=[];for(let e=0;e<this.movelist.length;e++)t.push(this.parsemove(this.movelist[e]));this.parsedmovelist=t}}getfaces(){return this.faces.map(t=>t.map(t=>[t.b,t.c,t.d]))}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;if(e>30)throw new Error("Too many slices for getmovesets bitmasks");let s=[];if(void 0!==this.parsedmovelist)for(let i=0;i<this.parsedmovelist.length;i++){const o=this.parsedmovelist[i];o[1]===t&&(o[4]?s.push((2<<o[3])-(1<<o[2])):s.push((2<<e-o[2])-(1<<e-o[3])),s.push(o[5]))}else if(this.vertexmoves&&!this.allmoves){const i=this.movesetgeos[t];if(i[1]!==i[3])for(let t=0;t<e;t++)"v"!==i[1]?(this.outerblockmoves?s.push((2<<e)-(2<<t)):s.push(2<<t),s.push(1)):(this.outerblockmoves?s.push((2<<t)-1):s.push(1<<t),s.push(1))}else for(let t=0;t<=e;t++)(this.allmoves||t+t!==e)&&(this.outerblockmoves?t+t>e?s.push((2<<e)-(1<<t)):s.push((2<<t)-1):s.push(1<<t),s.push(1));if(this.fixedCubie>=0){const i=1<<+this.cubiekeys[this.fixedCubie].trim().split(" ")[t],o=[];for(let t=0;t<s.length;t+=2){let n=s[t];n&i&&(n=(2<<e)-1-n);let r=!1;for(let e=0;e<o.length;e+=2)if(o[e]===n&&o[e+1]===s[t+1]){r=!0;break}r||(o.push(n),o.push(s[t+1]))}s=o}return this.addrotations&&(s.push((2<<e)-1),s.push(1)),s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&(this.graycenters||!this.centersets)||2===e&&(this.grayedges||!this.edgesets)||e>2&&(this.graycorners||!this.cornersets)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&!this.centersets||2===e&&!this.edgesets||e>2&&!this.cornersets}skipcubie(t){if(0===t.length)return!0;const e=t[0];return this.skipbyori(e)}skipset(t){if(0===t.length)return!0;const e=t[0];return this.skipbyori(this.facetocubies[e][0])}header(t){return t+"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\n"+t+this.args+"\n"}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let i=0;i<t.moveops.length;i++){const o="M_"+t.movenames[i];s.push(o),e.push(o+":="+t.moveops[i].toPerm().toGap()+";")}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const i=t.solved.identicalPieces();return e.push("ip:=["+i.map(t=>"["+t.map(t=>t+1).join(",")+"]").join(",")+"];"),e.push(""),this.header("# ")+e.join("\n")}writeksolve(t="PuzzleGeometryPuzzle",e=!1){const s=this.getOrbitsDef(e);return e?s.toKsolve(t,e).join("\n"):this.header("# ")+s.toKsolve(t,e).join("\n")}writekpuzzle(){return this.getOrbitsDef(!0).toKpuzzle()}getOrbitsDef(t){const e=[],s=[],i=[];for(let t=0;t<this.moveplanesets.length;t++){const s=this.getmovesets(t);for(let t=0;t<s.length;t+=2)for(let e=0;e<t;e+=2)if(s[t]===s[e]&&s[t+1]===s[e+1])throw new Error("Redundant moves in moveset.");let i=0;for(let t=0;t<s.length;t+=2)i|=s[t];const o=this.cmovesbyslice[t];for(let t=0;t<o.length;t++){if(0==(i>>t&1))continue;const s=o[t];for(let t=0;t<s.length;t++){if(this.skipcubie(s[t]))continue;e[this.cubiesetnums[s[t][0]]]=1}}}for(let t=0;t<this.cubiesetnames.length;t++)e[t]&&(s.push(this.cubiesetnames[t]),i.push(new OrbitDef(this.cubieords[t],this.killorientation?1:this.orbitoris[t])));const o=[];for(let s=0;s<this.cubiesetnames.length;s++){if(!e[s])continue;const i=[],n=[];for(let e=0;e<this.cubieords[s];e++){if(t)i.push(e);else{const t=this.cubiesetcubies[s][e];i.push(this.cubievaluemap[t])}n.push(0)}o.push(new Orbit(i,n,this.killorientation?1:this.orbitoris[s]))}const n=[],r=[];for(let t=0;t<this.moveplanesets.length;t++){const s=this.moveplanesets[t].length,i=this.getmovesets(t),o=this.movesetgeos[t];for(let h=0;h<i.length;h+=2){const l=i[h],a=d(o,l,s),c=a[0],f=a[1];n.push(c);const u=[],m=[],p=[];for(let t=0;t<this.cubiesetnames.length;t++){const e=[];for(let s=0;s<this.cubieords[t];s++)e.push(s);m.push(e);const s=[];for(let e=0;e<this.cubieords[t];e++)s.push(0);p.push(s)}const g=this.cmovesbyslice[t];for(let t=0;t<g.length;t++){if(0==(l>>t&1))continue;const e=g[t];for(let t=0;t<e.length;t++){const s=e[t].slice(),i=this.cubiesetnums[s[0]];for(let t=0;t<s.length;t+=2)s[t]=this.cubieordnums[s[t]];let o=2,n=3;f&&(o=s.length-2,n=s.length-1);for(let t=0;t<s.length;t+=2)m[i][s[(t+o)%s.length]]=s[t],this.killorientation?p[i][s[t]]=0:p[i][s[t]]=(s[(t+n)%s.length]-s[(t+1)%s.length]+this.orbitoris[i])%this.orbitoris[i]}}for(let t=0;t<this.cubiesetnames.length;t++){if(!e[t])continue;const s=new Array(p[t].length);for(let e=0;e<m[t].length;e++)s[e]=p[t][m[t][e]];u.push(new Orbit(m[t],s,this.killorientation?1:this.orbitoris[t]))}let b=new Transformation(u);1!==i[h+1]&&(b=b.mulScalar(i[h+1])),r.push(b)}}this.ksolvemovenames=n;let h=new OrbitsDef(s,i,new VisibleState(o),n,r);return this.optimize&&(h=h.optimize()),0!==this.scramble&&h.scramble(this.scramble),h}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(t=>t.toPerm())}showcanon(t){!function(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const i=[],o=[];for(let e=0;e<s;e++){const n=t.moveops[e];i.push(n.order());let r=0;for(let i=0;i<s;i++){if(i===e)continue;const s=t.moveops[i];n.mul(s).equal(s.mul(n))&&(r|=1<<i)}o.push(r)}let n={0:1};for(let t=0;t<100;t++){let s=0;const r={};let h=0;for(const t in n){const e=+t,l=n[e];s+=l,h++;for(let t=0;t<i.length;t++)if(0==(e>>t&1)&&0==(e&o[t]&(1<<t)-1)){const s=e&o[t]|1<<t;void 0===r[s]&&(r[s]=0),r[s]+=(i[t]-1)*l}}e(t+": canonseq "+s+" states "+h),n=r}}(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.basefacecount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new Perm(t)}getInitial3DRotation(){const t=this.basefacecount;if(4===t)return new Quat(.7043069543230507,.0617237605829268,.4546068756768417,.5417328493446099);if(6===t)return new Quat(.3419476009844782,.17612448544695208,-.42284908551877964,.8205185279339757);if(8===t)return new Quat(-.6523285484575103,.2707374015470506,.6537994145576647,.27150515611112014);if(12===t)return new Quat(-.5856747836703331,.02634133605619232,.7075560342412421,.39453217891103587);if(20===t)return new Quat(.7052782621769977,.6377976252204238,.30390357803973855,.05864620549043545);throw new Error("Wrong base face count")}generatesvg(t=800,e=500,s=10,i=!1){function o(t,e){let s=t[1][0]-t[0][0],i=t[1][1]-t[0][1];const o=2*Math.PI/e,n=Math.cos(o),r=Math.sin(o);for(let o=2;o<e;o++){const e=s*n+i*r;i=i*n-s*r,s=e,t.push([t[o-1][0]+s,t[o-1][1]+i])}}function n(t){return t+0*(Math.random()-.5)}function r(t,e,s){return'<polygon id="'+t+'" class="sticker" style="fill: '+s+'" points="'+e.map(t=>n(t[0])+" "+n(t[1])).join(" ")+'"/>\n'}t-=2*s,e-=2*s;let h=this.addrotations,l=this.addrotations,a=this.addrotations;for(let t=0;t<this.movesetgeos.length;t++){const e=this.movesetgeos[t];for(let t=1;t<=3;t+=2)"v"===e[t]&&(h=!0),"f"===e[t]&&(a=!0),"e"===e[t]&&(l=!0)}this.genperms();const f=this.getboundarygeometry().facenames[0][0].length,u=this.net;if(null===u)throw new Error("No net?");const m={};let p=0,g=0,d=1,v=0;m[u[0][0]]=[[1,0],[0,0]],o(m[u[0][0]],f);for(let t=0;t<u.length;t++){const e=u[t][0];if(!m[e])throw new Error("Bad edge description; first edge not connected.");for(let s=1;s<u[t].length;s++){const i=u[t][s];""===i||m[i]||(m[i]=[m[e][s%f],m[e][(s+f-1)%f]],o(m[i],f))}}for(const t in m){const e=m[t];for(let t=0;t<e.length;t++)p=Math.min(p,e[t][0]),d=Math.max(d,e[t][0]),g=Math.min(g,e[t][1]),v=Math.max(v,e[t][1])}const w=Math.min(t/(d-p),e/(v-g)),x=.5*(t-w*(d+p)),y=.5*(e-w*(v+g)),k={},z=this.getboundarygeometry(),M={},E=[[w+x,y],[x,y]];M[u[0][0]]=E,o(M[u[0][0]],f),k[this.facenames[0][1]]=this.project2d(0,0,[new Quat(0,E[0][0],E[0][1],0),new Quat(0,E[1][0],E[1][1],0)]);const P=[];P[0]=0;for(let t=0;t<u.length;t++){const e=u[t][0];if(!M[e])throw new Error("Bad edge description; first edge not connected.");let s=-1;for(let t=0;t<z.facenames.length;t++)if(e===z.facenames[t][1]){s=t;break}if(s<0)throw new Error("Could not find first face name "+e);const i=z.facenames[s][0];for(let n=1;n<u[t].length;n++){const r=u[t][n];if(""===r||M[r])continue;M[r]=[M[e][n%f],M[e][(n+f-1)%f]],o(M[r],f);const h=P[s],l=i[(h+n)%f].sum(i[(h+n+f-1)%f]).smul(.5),a=c(z.edgenames,l),m=b(z.edgenames[a][1],this.facenames),p=m[e===m[0]?1:0];let g=-1;for(let t=0;t<z.facenames.length;t++)if(p===z.facenames[t][1]){g=t;break}if(g<0)throw new Error("Could not find second face name");const d=z.facenames[g][0];for(let t=0;t<d.length;t++){if(d[t].sum(d[(t+1)%f]).smul(.5).dist(l)<=1e-9){const s=M[e][(n+f-1)%f],i=M[e][n%f];P[g]=t,k[p]=this.project2d(g,t,[new Quat(0,i[0],i[1],0),new Quat(0,s[0],s[1],0)]);break}}}}const O=this.getsolved(),D=[],B=[];for(let t=0;t<this.basefacecount;t++)D[t]=this.colors[this.facenames[t][1]];let Q=0,C=0;const F=this.getInitial3DRotation();for(let t=0;t<this.faces.length;t++){let e=this.faces[t];e=F.rotateface(e);for(let t=0;t<e.length;t++)Q=Math.max(Q,Math.abs(e[t].b)),C=Math.max(C,Math.abs(e[t].c))}const R=Math.min(e/C/2,(t-s)/Q/4),S=this;function A(o,n){if(i){const i=.5*s+.25*t,r=S.baseplanes[o].rotateplane(F).d<0?1:-1;return[s+.5*t+r*(i-n.b*R),s+.5*e+n.c*R]}{const t=k[S.facenames[o][1]];return[s+n.dot(t[0])+t[2].b,s+e-n.dot(t[1])-t[2].c]}}for(let t=0;t<this.faces.length;t++){let e=S.faces[t];const s=Math.floor(t/S.stickersperface);i&&(e=F.rotateface(e)),B.push(e.map(t=>A(s,t)))}const j=[];for(let t=0;t<this.basefacecount;t++){j.push("<g>"),j.push("<title>"+this.facenames[t][1]+"</title>\n");for(let e=0;e<this.stickersperface;e++){const s=t*this.stickersperface+e,i=this.facetocubies[s][0],o=this.facetocubies[s][1],n=this.cubiesetnums[i],h=this.cubieordnums[i],l=this.graybyori(i)?"#808080":D[O.p[s]];let a=this.cubiesetnames[n]+"-l"+h+"-o"+o;if(j.push(r(a,B[s],l)),this.duplicatedFaces[s])for(let t=1;t<this.duplicatedFaces[s];t++)a=this.cubiesetnames[n]+"-l"+h+"-o"+t,j.push(r(a,B[s],l))}j.push("</g>")}const I=[];function T(t,e,s,i){const o=A(t,s);for(let t=0;t<I.length;t++)if(Math.hypot(o[0]-I[t][0],o[1]-I[t][1])<1e-9)return;I.push([o[0],o[1],e,i])}for(let t=0;t<this.faceplanes.length;t++){const e=this.facenames[t][0];let s=e;if(i&&(s=F.rotateface(s)),a){let e=this.faceplanes[t][0];i&&(e=e.rotatepoint(F)),T(t,this.faceplanes[t][1],e,f)}for(let i=0;i<e.length;i++){if(l){const o=e[i].sum(e[(i+1)%e.length]).smul(.5),n=c(this.edgenames,o),r=s[i].sum(s[(i+1)%e.length]).smul(.5);T(t,this.edgenames[n][1],r,2)}if(h){const o=c(this.vertexnames,e[i]);T(t,this.vertexnames[o][1],s[i],this.cornerfaces)}}}const L='<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n'+j.join("")+"</svg>";return this.svggrips=I,L}get3d(t){const e=[],s=this.getInitial3DRotation(),i=[],o=.52*this.basefaces[0][0].len();for(let t=0;t<this.basefaces.length;t++){const e=s.rotateface(this.basefaces[t]),n=this.facenames[t][1];i.push({coords:w(e,o),name:n})}for(let i=0;i<this.faces.length;i++){const n=Math.floor(i/this.stickersperface),r=this.facetocubies[i][0],h=this.facetocubies[i][1],l=this.cubiesetnums[r],a=this.cubieordnums[r],c=this.graybyori(r)?"#808080":this.colors[this.facenames[n][1]];let f=s.rotateface(this.faces[i]);if(t&&t>0&&(f=x(f,t)),e.push({coords:w(f,o),color:c,orbit:this.cubiesetnames[l],ord:a,ori:h}),this.duplicatedFaces[i])for(let t=1;t<this.duplicatedFaces[i];t++)e.push({coords:w(f,o),color:c,orbit:this.cubiesetnames[l],ord:a,ori:t})}const n=[];for(let t=0;t<this.movesetgeos.length;t++){const e=this.movesetgeos[t],i=this.movesetorders[t];for(let t=0;t<this.geonormals.length;t++){const o=this.geonormals[t];e[0]===o[1]&&e[1]===o[2]&&(n.push([v(o[0].rotatepoint(s),1),e[0],i]),n.push([v(o[0].rotatepoint(s).smul(-1),1),e[2],i]))}}return{stickers:e,faces:i,axis:n}}}class FactoredNumber{constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e==0;)void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)void 0!==this.mult[e]&&(""!==t&&(t+="*"),t+=e,this.mult[e]>1&&(t+="^"+this.mult[e]));return t}}function y(e,s){const i=e[0].p.length,o=function(e){return new Perm(t(e))}(i);let n=[],r=[],h=[],l=[],a=[];function c(t,e,s){l[t].push(e),a[t].push(s);for(let i=0;i<n[t].length;i++)n[t][i]&&f(t,n[t][i].mul(e),s+h[t][i])}function f(t,e,s){const i=e.p[t];if(!n[t][i]){n[t][i]=e,r[t][i]=e.inv(),h[t][i]=s;for(let i=0;i<l[t].length;i++)f(t,e.mul(l[t][i]),s+a[t][i]);return}const o=e.mul(r[t][i]);(function(t){for(let e=t.p.length-1;e>=0;e--){const s=t.p[e];if(s!==e){if(!n[e][s])return!1;t=t.mul(r[e][s])}}return!0})(o)||c(t-1,o,s+h[t][i])}return function(){n=[],r=[],l=[],h=[],a=[];for(let t=0;t<i;t++)n.push([]),r.push([]),h.push([]),l.push([]),a.push([]),n[t][t]=o,r[t][t]=o,h[t][t]=0;let t=0,f=1;for(let o=0;o<e.length;o++){c(i-1,e[o],1),f=1;let r=0,a=0;const u=new FactoredNumber;for(let e=0;e<i;e++){let s=0,o=0;for(let r=0;r<i;r++)n[e][r]&&(s++,o+=h[e][r],e!==r&&t++);r+=l[e].length,f*=s,s>1&&u.multiply(s),a+=o/s}s(o+": sz "+f+" T "+r+" sol "+a+" none "+t+" mults "+u)}return f}()}var k=Object.freeze({__proto__:null,Perm:Perm,Orbit:Orbit,OrbitDef:OrbitDef,OrbitsDef:OrbitsDef,Transformation:Transformation,VisibleState:VisibleState,getpuzzle:u,getPuzzleGeometryByDesc:p,getPuzzleGeometryByName:g,getpuzzles:f,parsedesc:m,PuzzleGeometry:PuzzleGeometry,Quat:Quat,schreierSims:y});exports.Orbit=Orbit,exports.OrbitDef=OrbitDef,exports.OrbitsDef=OrbitsDef,exports.Perm=Perm,exports.PuzzleGeometry=PuzzleGeometry,exports.Quat=Quat,exports.Transformation=Transformation,exports.VisibleState=VisibleState,exports.getPuzzleGeometryByDesc=p,exports.getPuzzleGeometryByName=g,exports.getpuzzle=u,exports.getpuzzles=f,exports.index=k,exports.parsedesc=m,exports.schreierSims=y;
//# sourceMappingURL=index-9e066b27.js.map
